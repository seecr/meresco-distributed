## begin license ##
#
# Drents Archief beoogt het Drents erfgoed centraal beschikbaar te stellen.
#
# Copyright (C) 2012-2016 Seecr (Seek You Too B.V.) http://seecr.nl
# Copyright (C) 2012-2014 Stichting Bibliotheek.nl (BNL) http://www.bibliotheek.nl
# Copyright (C) 2015-2016 Koninklijke Bibliotheek (KB) http://www.kb.nl
# Copyright (C) 2016 Drents Archief http://www.drentsarchief.nl
#
# This file is part of "Drents Archief"
#
# "Drents Archief" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "Drents Archief" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "Drents Archief"; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
## end license ##

from os.path import isfile, join
from os import rename
from StringIO import StringIO
from time import sleep
from sys import stdout

from seecr.utils import Version
from re import compile
from meresco.distributed.utils import usrSharePath as defaultUsrSharePath


READABLE = 'readable'
WRITABLE = 'writable'
ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY = 'debug.global.adminDownload.period'
SERVICE_POLL_INTERVAL = 30

class NginxConfig(object):
    def __init__(self, type, nginxConfigDir, minVersion, untilVersion, verbose=False, unused=False, flag=READABLE, usrSharePath=None, name=None, **ignored):
        assert type.strip() != '', "Expected a type name."
        self._type = type
        self._name = self._type if name is None else name
        namecheck(self._name)
        self._nginxConfigFile = join(nginxConfigDir, '%s.frontend.conf' % self._name)
        self._verbose = verbose
        self._minVersion = Version(minVersion)
        self._untilVersion = Version(untilVersion)
        self._unused = unused
        self._flag = flag
        self._usrSharePath = join(defaultUsrSharePath, 'failover') if usrSharePath  is None else usrSharePath

    def updateConfig(self, config, services, **ignored):
        typeConfig = config['%s.frontend' % self._type]
        sleeptime = typeConfig.get('reconfiguration.interval', config.get(ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY, SERVICE_POLL_INTERVAL))
        mustUpdate = self._updateConfig(services, typeConfig)
        self._log("Sleeping: %ss\n" % sleeptime)
        return mustUpdate, sleeptime

    def _updateConfig(self, services, typeConfig):
        matchingServices = self._selectHostAndPort(services)
        serverName = typeConfig['fqdn']
        aliases = ' '.join(typeConfig.get('aliases', []))
        if aliases:
            serverName += ' %s' % aliases
        listenPort = typeConfig.get('port', 80)
        listenIp = typeConfig.get('ipAddress', typeConfig.get('ip', '0.0.0.0'))
        usrSharePath = self._usrSharePath
        conf = StringIO()
        conf.write("## Generated by NginxConfig\n")
        if not self._unused and len(matchingServices) > 0:
            conf.write("""upstream __var_%s {\n""" % self._name)
            for host, port in sorted(matchingServices):
                conf.write("    server {host}:{port};\n".format(host=host, port=port))
                self._log("Service {type} at {host}:{port}\n".format(host=host, port=port, type=self._type))
            name = self._name
            throttling = typeConfig.get('throttling', {})
            if '/' not in throttling:
                throttling['/'] = {}
            locations = []
            zones = []
            for location, data in throttling.items():
                zone_name = location.replace("/", "")
                byIp, total = "", ""
                locationData = StringIO()
                locationData.write("""    location {location} {{
        proxy_pass http://__var_{name};\n""".format(name=name, location=location))
                if 'max_connections_per_ip' in data:
                    locationData.write("        limit_conn {name}-{0}-byip {1};\n".format(zone_name, data['max_connections_per_ip'], name=self._name))
                    zones.append("limit_conn_zone $binary_remote_addr zone={name}-{0}-byip:10m;".format(zone_name, name=self._name))
                if 'max_connections' in data:
                    locationData.write("        limit_conn {name}-{0}-total {1};\n".format(zone_name, data['max_connections'], name=self._name))
                    zones.append("limit_conn_zone $server_name zone={name}-{0}-total:10m;".format(zone_name, name=self._name))
                locationData.write("    }\n")
                locations.append(locationData.getvalue())
            locations = "\n".join(locations)
            zones = "\n".join(zones)
            conf.write("""}

%(zones)s

server {
    listen %(listenIp)s:%(listenPort)s;
    server_name %(serverName)s;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

%(locations)s
    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %(usrSharePath)s;
    }
    client_max_body_size 0;
}\n""" % locals())
        elif self._unused:
            conf.write("""
server {
    listen %(listenIp)s:%(listenPort)s;
    server_name %(serverName)s;
    root %(usrSharePath)s;
    location / {
        location /unused.html {
        }
        return 410;
    }
    error_page 410 /unused.html;
}\n""" % locals())
        else:
            conf.write("""
server {
    listen %(listenIp)s:%(listenPort)s;
    server_name %(serverName)s;
    root %(usrSharePath)s;  # Note that nginx won't read in a directory for which the root user doesn't have read permissions.
    location / {
        location /unavailable.html {
        }
        return 503;
    }
    error_page 503 /unavailable.html;
}\n""" % locals())

        if not isfile(self._nginxConfigFile) or conf.getvalue() != open(self._nginxConfigFile).read():
            with open(self._nginxConfigFile+'~', 'w') as fd:
                fd.write(conf.getvalue())
            rename(self._nginxConfigFile+'~', self._nginxConfigFile)
            return True
        return False

    def _sleep(self, sleeptime):
        sleep(sleeptime)

    def _log(self, msg):
        if not self._verbose:
            return
        stdout.write(msg)
        stdout.flush()

    def _selectHostAndPort(self, services):
        matchingServices = []
        for serviceIdentifier, service in services.items():
            if not service.get(self._flag, False):
                continue
            if service['type'] == self._type:
                if self._minVersion <= Version(service['data']['VERSION']) < self._untilVersion:
                    matchingServices.append((service['ipAddress'], service['infoport']))
        return matchingServices

NAME_RE = compile(r'^\w+$')
def namecheck(name):
    if not NAME_RE.match(name):
        raise ValueError('Only alphanumeric characters allowed.')
