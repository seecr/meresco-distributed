## begin license ##
#
# Drents Archief beoogt het Drents erfgoed centraal beschikbaar te stellen.
#
# Copyright (C) 2012-2016 Seecr (Seek You Too B.V.) http://seecr.nl
# Copyright (C) 2012-2014 Stichting Bibliotheek.nl (BNL) http://www.bibliotheek.nl
# Copyright (C) 2015-2016 Koninklijke Bibliotheek (KB) http://www.kb.nl
# Copyright (C) 2016 Drents Archief http://www.drentsarchief.nl
#
# This file is part of "Drents Archief"
#
# "Drents Archief" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "Drents Archief" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "Drents Archief"; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
## end license ##

from os.path import isfile, join
from os import rename
from StringIO import StringIO
from time import sleep
from sys import stdout

from seecr.utils import Version
from re import compile
from meresco.components import parseAbsoluteUrl
from meresco.distributed.utils import usrSharePath as defaultUsrSharePath
from warnings import warn


READABLE = 'readable'
WRITABLE = 'writable'
ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY = 'debug.global.adminDownload.period'
SERVICE_POLL_INTERVAL = 30

class NginxConfig(object):
    def __init__(self, type, nginxConfigDir, minVersion, untilVersion, verbose=False, unused=False, flags=None, usrSharePath=None, name=None, sslCertificate=None, sslKey=None, endpoint=None, **ignored):
        assert type.strip() != '', "Expected a type name."
        self._type = type
        self._name = self._type if name is None else name
        namecheck(self._name)
        self._nginxConfigFile = join(nginxConfigDir, '%s.frontend.conf' % self._name)
        self._verbose = verbose
        self._minVersion = Version.create(minVersion)
        self._untilVersion = Version.create(untilVersion)
        self._unused = unused
        self._flags = [READABLE] if not flags else flags
        if 'flag' in ignored and ignored['flag'] is not None:
            self._flags=[ignored['flag']]
            warn("Option 'flag' has been replaced by 'flags'", DeprecationWarning)
        self._usrSharePath = join(defaultUsrSharePath, 'failover') if usrSharePath  is None else usrSharePath
        self._sslLines = _ssl(sslCertificate, sslKey)
        self._defaultPort = 443 if self._sslLines else 80
        self._endpoint = endpoint

    def updateConfig(self, config, services, **ignored):
        typeConfig = config['%s.frontend' % self._type]
        sleeptime = typeConfig.get('reconfiguration.interval', config.get(ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY, SERVICE_POLL_INTERVAL))
        mustUpdate = self._updateConfig(services, typeConfig)
        self._log("Sleeping: %ss\n" % sleeptime)
        return mustUpdate, sleeptime

    def _updateConfig(self, services, typeConfig):
        matchingServices = self._selectHostAndPort(services)
        serverName = typeConfig['fqdn']
        aliases = ' '.join(typeConfig.get('aliases', []))
        if aliases:
            serverName += ' %s' % aliases
        listenPort = typeConfig.get('port', self._defaultPort)
        listenIps = [ip for ip in ([typeConfig.get('ipAddress', typeConfig.get('ip'))] + typeConfig.get('ipAddresses',[])) if ip]
        if not listenIps:
            listenIps.append('0.0.0.0')
        listenLines = ""
        for listenIp in listenIps:
            listenLines += "    listen %(listenIp)s:%(listenPort)s;\n" % locals()
        usrSharePath = self._usrSharePath
        sslLines = self._sslLines
        conf = StringIO()
        conf.write("## Generated by NginxConfig\n")
        if not self._unused and len(matchingServices) > 0:
            conf.write("""upstream __var_%s {\n""" % self._name)
            for host, port in sorted(matchingServices):
                conf.write("    server {host}:{port};\n".format(host=host, port=port))
                self._log("Service {type} at {host}:{port}\n".format(host=host, port=port, type=self._type))
            locations, zones = self._throttling(typeConfig.get('throttling', {}))
            conf.write("""}

%(zones)s

server {
%(listenLines)s
    server_name %(serverName)s;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
%(sslLines)s
%(locations)s
    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %(usrSharePath)s;
    }
    client_max_body_size 0;
}\n""" % locals())
        elif self._unused:
            conf.write("""
server {
%(listenLines)s
    server_name %(serverName)s;
    root %(usrSharePath)s;
%(sslLines)s
    location / {
        location /unused.html {
        }
        return 410;
    }
    error_page 410 /unused.html;
}\n""" % locals())
        else:
            conf.write("""
server {
%(listenLines)s
    server_name %(serverName)s;
    root %(usrSharePath)s;  # Note that nginx won't read in a directory for which the root user doesn't have read permissions.
%(sslLines)s
    location / {
        location /unavailable.html {
        }
        return 503;
    }
    error_page 503 /unavailable.html;
}\n""" % locals())

        if not isfile(self._nginxConfigFile) or conf.getvalue() != open(self._nginxConfigFile).read():
            with open(self._nginxConfigFile+'~', 'w') as fd:
                fd.write(conf.getvalue())
            rename(self._nginxConfigFile+'~', self._nginxConfigFile)
            return True
        return False

    def _throttling(self, throttling):
        if '/' not in throttling:
            throttling['/'] = {}
        locations = []
        zones = []
        for location, data in throttling.items():
            zone_name = location.replace("/", "")
            locationData = StringIO()
            locationData.write("""    location {location} {{
    proxy_pass http://__var_{name};\n""".format(name=self._name, location=location))
            if 'max_connections_per_ip' in data:
                locationData.write("        limit_conn {name}-{0}-byip {1};\n".format(zone_name, data['max_connections_per_ip'], name=self._name))
                zones.append("limit_conn_zone $binary_remote_addr zone={name}-{0}-byip:10m;".format(zone_name, name=self._name))
            if 'max_connections' in data:
                locationData.write("        limit_conn {name}-{0}-total {1};\n".format(zone_name, data['max_connections'], name=self._name))
                zones.append("limit_conn_zone $server_name zone={name}-{0}-total:10m;".format(zone_name, name=self._name))
            locationData.write("    }\n")
            locations.append(locationData.getvalue())
        return "\n".join(locations), "\n".join(zones)

    def _sleep(self, sleeptime):
        sleep(sleeptime)

    def _log(self, msg):
        if not self._verbose:
            return
        stdout.write(msg)
        stdout.flush()

    def _selectHostAndPort(self, services):
        matchingServices = []
        for serviceIdentifier, service in services.items():
            if not all(service.get(flag, False) for flag in self._flags):
                continue
            if service['type'] != self._type:
                continue
            if self._minVersion <= Version(service['data']['VERSION']) < self._untilVersion:
                if self._endpoint is None:
                    matchingServices.append((service['ipAddress'], service['infoport']))
                else:
                    endpoint = parseAbsoluteUrl(service['data'].get('endpoints',{}).get(self._endpoint, ''))
                    if endpoint is not None:
                        matchingServices.append((endpoint['host'], endpoint['port']))

        return matchingServices

NAME_RE = compile(r'^\w+$')
def namecheck(name):
    if not NAME_RE.match(name):
        raise ValueError('Only alphanumeric characters allowed.')

def _ssl(sslCertificate, sslKey):
    if sslCertificate is None and sslKey is None:
        return ""
    if sslCertificate is None or sslKey is None:
        raise ValueError("Bad configuration, expected both 'sslCertificate' and 'sslKey'.")
    return """
    ssl on;

    ssl_certificate         {sslCertificate};
    ssl_certificate_key     {sslKey};
    ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;
    keepalive_timeout       60;
    ssl_session_cache       shared:SSL:10m;

    proxy_redirect          http:// https://;
""".format(**locals())