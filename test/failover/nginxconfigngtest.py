## begin license ##
#
# "Meresco Distributed" has components for group management based on "Meresco Components."
#
# Copyright (C) 2016 SURFmarket https://surf.nl
# Copyright (C) 2016 Seecr (Seek You Too B.V.) http://seecr.nl
#
# This file is part of "Meresco Distributed"
#
# "Meresco Distributed" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "Meresco Distributed" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "Meresco Distributed"; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
## end license ##

from seecr.test import SeecrTestCase, CallTrace
from meresco.distributed.failover import NginxConfigNG, SslConfig, ServiceConfig
from weightless.core import asString, consume, asList
from os.path import join
from uuid import uuid4

class NginxConfigNGTest(SeecrTestCase):
    def setUp(self):
        SeecrTestCase.setUp(self)
        self.config = NginxConfigNG(join(self.tempdir, 'server.conf'))


    def testEmpty(self):
        observer = CallTrace(methods=dict(servernames=lambda:(f for f in ['example.org'])), emptyGeneratorMethods=['sslLines', 'matchingServices', 'zones', 'listenLines', 'locations', 'updateConfig'])
        self.config.addObserver(observer)
        result = self.config.generate(config={'some':'thing'}, services={'services':[]})
        self.assertEqualsWS('''## Generated by NginxConfig

server {
    server_name example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        location /unavailable.html {
        }
        return 503;
    }

    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root /home/sharekit/meresco-distributed/usr-share/failover;
    }
    client_max_body_size 0;
}''', result)
        self.assertEquals([
                'updateConfig',
                'matchingServices',
                'zones',
                'listenLines',
                'servernames',
                'sslLines',
                'locations',
            ], observer.calledMethodNames())
        self.assertEqual(dict(config={'some':'thing'}, services={'services':[]}), observer.calledMethods[0].kwargs)
        self.assertEqual((), observer.calledMethods[0].args)
        for m in observer.calledMethods[1:]:
            self.assertEqual(dict(), m.kwargs)
            self.assertEqual((), m.args)

    def testNoServernamesMeansError(self):
        self.assertRaises(ValueError, lambda:self.config.generate())

    def testUpdateConfig(self):
        self.config.generate = lambda **kwargs: 'config'
        result = self.config.update(config={}, services={})
        self.assertEqual((True, 30), (result.mustUpdate, result.sleeptime))
        result = self.config.update(config={}, services={})
        self.assertEqual((False, 30), result)
        self.config.generate = lambda **kwargs: 'config2'
        result = self.config.update(config={}, services={})
        self.assertEqual((True, 30), result)
        self.assertEqual('config2', open(join(self.tempdir, 'server.conf')).read())

    def testSslConfig(self):
        c = SslConfig(certificate='/path/to/ssl.crt', key='/path/to/ssl.pem')
        self.assertEqual('''
    ssl on;

    ssl_certificate         /path/to/ssl.crt;
    ssl_certificate_key     /path/to/ssl.pem;
    ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;
    keepalive_timeout       60;
    ssl_session_cache       shared:SSL:10m;

    proxy_redirect          http:// https://;
''', asString(c.sslLines()))

    def testServiceConfig(self):
        c = ServiceConfig(type='api', minVersion="4.2", untilVersion="5.0")
        consume(c.updateConfig(**CONFIG_SERVICES()))
        self.assertEquals(['api.front.example.org', 'alias1', 'alias2'], asList(c.servernames()))
        self.assertEquals('', asString(c.zones()))
        self.assertEquals('    location / {\n        proxy_pass http://__var_api;\n    }', asString(c.locations()))
        self.assertEquals('    listen 0.0.0.0:80;\n', asString(c.listenLines()))

    def testServiceConfigThrottling(self):
        c = ServiceConfig(type='api', minVersion="4.2", untilVersion="5.0", path='/main')
        configServices = CONFIG_SERVICES()
        configServices['config']['api.frontend']['throttling'] = {
            '/path': {'max_connections_per_ip' : 10, 'max_connections': 100},
            '/other': {'max_connections_per_ip' : 30, 'max_connections': 150}
        }
        consume(c.updateConfig(**configServices))
        self.assertEquals([
            'limit_conn_zone $binary_remote_addr zone=api-other-byip:10m;',
            'limit_conn_zone $server_name zone=api-other-total:10m;',
            'limit_conn_zone $binary_remote_addr zone=api-path-byip:10m;',
            'limit_conn_zone $server_name zone=api-path-total:10m;'
            ], asString(c.zones()).split('\n'))
        self.assertEquals([
            '    location /main {',
            '        proxy_pass http://__var_api;',
            '    }',
            '    location /other {',
            '        proxy_pass http://__var_api;',
            '        limit_conn api-other-byip 30;',
            '        limit_conn api-other-total 150;',
            '    }',
            '    location /path {',
            '        proxy_pass http://__var_api;',
            '        limit_conn api-path-byip 10;',
            '        limit_conn api-path-total 100;',
            '    }',
            ], asString(c.locations()).split('\n'))

    def testServiceConfigListen(self):
        c = ServiceConfig(type='api', minVersion="4.2", untilVersion="5.0", path='/main', port=443)
        configServices = CONFIG_SERVICES()
        configServices['config']['api.frontend']['ipAddress'] = '10.0.0.1'
        configServices['config']['api.frontend']['ipAddresses'] = ['10.0.0.2', '10.0.0.3']
        consume(c.updateConfig(**configServices))
        self.assertEquals('    listen 10.0.0.1:443;\n    listen 10.0.0.2:443;\n    listen 10.0.0.3:443;\n', asString(c.listenLines()))



def CONFIG_SERVICES():
    return dict(
        services={
            newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'data':{'VERSION': "4.3"}},
        },
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
                'aliases': ['alias1', 'alias2']
            }
        })


newId = lambda: str(uuid4())