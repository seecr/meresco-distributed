## begin license ##
#
# Drents Archief beoogt het Drents erfgoed centraal beschikbaar te stellen.
#
# Copyright (C) 2012-2016 Seecr (Seek You Too B.V.) http://seecr.nl
# Copyright (C) 2012-2014 Stichting Bibliotheek.nl (BNL) http://www.bibliotheek.nl
# Copyright (C) 2015-2016 Koninklijke Bibliotheek (KB) http://www.kb.nl
# Copyright (C) 2016 Drents Archief http://www.drentsarchief.nl
#
# This file is part of "Drents Archief"
#
# "Drents Archief" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "Drents Archief" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "Drents Archief"; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
## end license ##

from seecr.test import SeecrTestCase

from meresco.distributed.failover import NginxConfig
from meresco.distributed.failover.nginxconfig import WRITABLE, usrSharePath
from os import stat
from os.path import isfile, join
from uuid import uuid4
from meresco.distributed.failover.nginxconfig import ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY, SERVICE_POLL_INTERVAL

newId = lambda: str(uuid4())

class NginxConfigTest(SeecrTestCase):
    def setUp(self):
        SeecrTestCase.setUp(self)

    def testShouldNotWriteNginxConfigFileIfNothingChanged(self):
        services={
            newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'data':{'VERSION': VERSION}},
        }
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
                'reconfiguration.interval': 20,
            }
        }

        n1 = NginxConfig(type='api', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n1.updateConfig(services=services, config=config)
        self.assertTrue(mustUpdate)
        self.assertEquals(20, sleeptime)
        self.assertTrue(isfile(join(self.tempdir, 'api.frontend.conf')))
        stats = stat(join(self.tempdir, 'api.frontend.conf'))

        n2 = NginxConfig(type='api', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n2.updateConfig(config=config, services=services)
        self.assertFalse(mustUpdate)
        self.assertEquals(stats, stat(join(self.tempdir, 'api.frontend.conf')))

    def testShouldUseNameIfGiven(self):
        services={
            newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'data':{'VERSION': VERSION}},
        }
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
                'reconfiguration.interval': 20,
            }
        }

        n1 = NginxConfig(type='api', name='api_14', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n1.updateConfig(config=config, services=services)
        self.assertTrue(mustUpdate)
        self.assertEquals(20, sleeptime)
        self.assertTrue(isfile(join(self.tempdir, 'api_14.frontend.conf')))

    def testBaseOnWritable(self):
        services={
                newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'writable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':2345, 'active':True, 'readable': True, 'writable': False, 'data':{'VERSION': VERSION}},
        }
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
                'reconfiguration.interval': 20,
                'ipAddress': '1.2.3.4',
            }
        }

        n1 = NginxConfig(type='api', name='name', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE, flag=WRITABLE)
        mustUpdate, sleeptime = n1.updateConfig(config=config, services=services)
        self.assertTrue(mustUpdate)
        self.assertEquals(20, sleeptime)
        self.assertTrue(isfile(join(self.tempdir, 'name.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_name {
    server 10.0.0.2:1234;
}

server {
    listen 1.2.3.4:80;
    server_name api.front.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        proxy_pass http://__var_name;
    }

    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'name.frontend.conf')).read())

    def testNameCheck(self):
        def name(name):
            return NginxConfig(type='api', name=name, nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        self.assertRaises(ValueError, name, 'api.1.4')
        self.assertRaises(ValueError, name, 'api.1$%_4')

        self.assertTrue(name('api_14'))


    def testShouldConfigureApiServers(self):
        n = NginxConfig(type='api', name='name', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':2345, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'plein', 'ipAddress':'10.0.0.4', 'infoport':2346, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'fqdn': 'api.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'name.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_name {
    server 10.0.0.2:1234;
    server 10.0.0.3:2345;
}

server {
    listen 0.0.0.0:80;
    server_name api.front.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        proxy_pass http://__var_name;
    }

    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'name.frontend.conf')).read())

    def testShouldConfigureAnyGivenTypeOfServiceWithPort(self):
        n = NginxConfig(type='other', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'other', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'other', 'ipAddress':'10.0.0.4', 'infoport':1235, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'other', 'ipAddress':'10.0.0.5', 'infoport':1236, 'active':True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':2345, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'other.frontend': {
                    'port': 8080,
                    'fqdn': 'other.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'other.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_other {
    server 10.0.0.2:1234;
    server 10.0.0.4:1235;
}

server {
    listen 0.0.0.0:8080;
    server_name other.front.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        proxy_pass http://__var_other;
    }
    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'other.frontend.conf')).read())

    def testShouldConfigureGivenAliases(self):
        n = NginxConfig(type='api', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'other', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':2345, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'port': 80,
                    'fqdn': 'api.front.example.org',
                    'aliases': [
                        'the.api.example.org',
                        '*.api.example.org',
                    ],
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'api.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_api {
    server 10.0.0.3:2345;
}

server {
    listen 0.0.0.0:80;
    server_name api.front.example.org the.api.example.org *.api.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        proxy_pass http://__var_api;
    }
    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'api.frontend.conf')).read())

    def testShouldConfigureErrorPageIfServiceNotAvailable(self):
        n = NginxConfig(type='api', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'other', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'port': 80,
                    'fqdn': 'api.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'api.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
server {
    listen 0.0.0.0:80;
    server_name api.front.example.org;
    root %s/failover;  # Note that nginx won't read in a directory for which the root user doesn't have read permissions.
    location / {
        location /unavailable.html {
        }
        return 503;
    }
    error_page 503 /unavailable.html;
}
""" % usrSharePath, open(join(self.tempdir, 'api.frontend.conf')).read())

    def testShouldConfigureErrorPageIfServicesNotReadable(self):
        n = NginxConfig(type='api', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':1235, 'active':True, 'readable': False, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'port': 80,
                    'fqdn': 'api.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'api.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
server {
    listen 0.0.0.0:80;
    server_name api.front.example.org;
    root %s/failover;  # Note that nginx won't read in a directory for which the root user doesn't have read permissions.
    location / {
        location /unavailable.html {
        }
        return 503;
    }
    error_page 503 /unavailable.html;
}
""" % usrSharePath, open(join(self.tempdir, 'api.frontend.conf')).read())

    def testShouldConfigureServicesWithCorrectVersion(self):
        n = NginxConfig(type='other', nginxConfigDir=self.tempdir, minVersion='0.42', untilVersion='0.43')
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'other', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': '0.41.1'}},
                newId(): {'type':'other', 'ipAddress':'10.0.0.4', 'infoport':1235, 'active':True, 'readable': True, 'data':{'VERSION': '0.42'}},
                newId(): {'type':'other', 'ipAddress':'10.0.0.8', 'infoport':1236, 'active':True, 'readable': True, 'data':{'VERSION': '0.42.3'}},
                newId(): {'type':'other', 'ipAddress':'10.0.0.16', 'infoport':1237, 'active':True, 'readable': True, 'data':{'VERSION': '0.43'}},
            },
            config={
                'other.frontend': {
                    'port': 8080,
                    'fqdn': 'other.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'other.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_other {
    server 10.0.0.4:1235;
    server 10.0.0.8:1236;
}

server {
    listen 0.0.0.0:8080;
    server_name other.front.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location / {
        proxy_pass http://__var_other;
    }
    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'other.frontend.conf')).read())

    def testShouldConfigureUnusedPage(self):
        n = NginxConfig(type='api', name='name', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE, unused=True)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'api', 'ipAddress':'10.0.0.2', 'infoport':1234, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':2345, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
                newId(): {'type':'plein', 'ipAddress':'10.0.0.4', 'infoport':2346, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'fqdn': 'api.front.example.org',
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'name.frontend.conf')))
        self.assertEqualsWS('''## Generated by NginxConfig

server {
    listen 0.0.0.0:80;
    server_name api.front.example.org;
    root %s/failover;
    location / {
        location /unused.html {
        }
        return 410;
    }
    error_page 410 /unused.html;
}
'''%usrSharePath, open(join(self.tempdir, 'name.frontend.conf')).read())


    def testShouldConfigureThrottling(self):
        n = NginxConfig(type='api', name='api_18', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n.updateConfig(
            services={
                newId(): {'type':'api', 'ipAddress':'10.0.0.3', 'infoport':1235, 'active':True, 'readable': True, 'data':{'VERSION': VERSION}},
            },
            config={
                'api.frontend': {
                    'port': 80,
                    'fqdn': 'api.front.example.org',
                    'throttling': {
                        '/sru': {
                            'max_connections': 10,
                            'max_connections_per_ip': 5
                        },
                        '/sru/holding': {}
                    }
                }
            }
        )
        self.assertEquals(True, mustUpdate)
        self.assertTrue(isfile(join(self.tempdir, 'api_18.frontend.conf')))
        self.assertEqualsWS("""## Generated by NginxConfig
upstream __var_api_18 {
    server 10.0.0.3:1235;
}

limit_conn_zone $binary_remote_addr zone=api_18-sru-byip:10m;
limit_conn_zone $server_name zone=api_18-sru-total:10m;

server {
    listen 0.0.0.0:80;
    server_name api.front.example.org;

    proxy_set_header    Host $host;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;

    location /sru {
        proxy_pass http://__var_api_18;
        limit_conn api_18-sru-byip 5;
        limit_conn api_18-sru-total 10;
    }

    location /sru/holding {
        proxy_pass http://__var_api_18;
    }

    location / {
        proxy_pass http://__var_api_18;
    }

    error_page 500 502 503 504 =503 /unavailable.html;
    location /unavailable.html {
        root %s/failover;
    }
    client_max_body_size 0;
}
""" % usrSharePath, open(join(self.tempdir, 'api_18.frontend.conf')).read())

    def testUseAdminDownloadPeriod(self):
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
            },
            ADMIN_DOWNLOAD_PERIOD_CONFIG_KEY: 5
        }
        n1 = NginxConfig(type='api', name='api_14', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n1.updateConfig(config=config, services={})
        self.assertEquals(5, sleeptime)

    def testUseAdminDownloadPeriodDefault(self):
        config={
            'api.frontend': {
                'fqdn': 'api.front.example.org',
            },
        }
        n1 = NginxConfig(type='api', name='api_14', nginxConfigDir=self.tempdir, minVersion=VERSION, untilVersion=VERSION_PLUS_ONE)
        mustUpdate, sleeptime = n1.updateConfig(config=config, services={})
        self.assertEquals(SERVICE_POLL_INTERVAL, sleeptime)

VERSION = '1.4'
VERSION_PLUS_ONE = '1.5'
